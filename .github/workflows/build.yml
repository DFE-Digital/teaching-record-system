name: Build

on:
  push:
    branches:
    - main
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
    branches:
    - main
  workflow_dispatch:
    inputs:
      deploy_to_production:
        type: boolean
        description: 'Deploy to production'
        default: false

env:
  CONTAINER_REGISTRY: ghcr.io

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  checks: write
  deployments: write
  packages: write
  pull-requests: write

jobs:
  generate_postgres_password:
    name: Generate Postgres password
    runs-on: ubuntu-latest
    outputs:
      POSTGRES_PASSWORD: ${{ steps.generate_password.outputs.POSTGRES_PASSWORD }}

    steps:
    - id: generate_password
      run: |
        chars=abcd1234ABCD
        for i in {1..8} ; do
          echo -n "POSTGRES_PASSWORD=${chars:RANDOM%${#chars}:1}" >> $GITHUB_OUTPUT
        done

  build:
    name: Build & test
    runs-on: ubuntu-latest
    concurrency: build
    needs: [generate_postgres_password]

    outputs:
      docker_image: ${{ env.tag }}

    services:
      postgres:
        image: postgres
        env:
          POSTGRES_PASSWORD: ${{ needs.generate_postgres_password.outputs.POSTGRES_PASSWORD }}
          POSTGRES_DB: dqt
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - uses: actions/checkout@v3

    - name: Extract configuration from tfvars
      id: config
      run: |
        KEY_VAULT_NAME=$(jq -r '.key_vault_name' $TFVARS)
        if [ -z "$KEY_VAULT_NAME" ]; then
          echo "::error ::Failed to extract key_vault_name from $TFVARS"
          exit 1
        fi
        echo "key_vault_name=$KEY_VAULT_NAME" >> $GITHUB_ENV
      env:
        TFVARS: dev.tfvars.json
      shell: bash
      working-directory: terraform

    - uses: Azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - uses: actions/setup-dotnet@v2
      with:
        dotnet-version: '6.0.x'

    - name: Lint
      run: |
        #https://github.com/dotnet/format/issues/1433
        dotnet tool install -g dotnet-format --version "6.*" --add-source https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet6/nuget/v3/index.json
        dotnet-format --verify-no-changes
      working-directory: DqtApi

    - name: Build
      run: dotnet build --configuration Release
      working-directory: DqtApi

    - uses: Azure/get-keyvault-secrets@v1
      id: get_secrets
      with:
        keyvault: ${{ env.key_vault_name }}
        secrets: 'INTEGRATION-TEST-CONFIG'

    - name: Set secret environment variables
      id: set_outputs
      run: |
        SECRET_KEYS=($(jq -r <<< "$SECRETS_JSON" | jq -r 'keys | @sh' | tr -d \'))
        for s in "${SECRET_KEYS[@]}"
        do
          SECRET=$(jq -r .${s} <<< "$SECRETS_JSON")
          echo "::add-mask::$SECRET"
          echo ${s}=$SECRET >> $GITHUB_ENV
        done
      env:
        SECRETS_JSON: ${{ steps.get_secrets.outputs.INTEGRATION-TEST-CONFIG }}
      shell: bash

    - name: Tests
      uses: ./.github/workflows/actions/test
      with:
        test_project_path: DqtApi/tests/DqtApi.Tests
        report_name: "Test results"
        dotnet_test_args: >-
          -e IntegrationTests_CrmUrl="${{ env.INTEGRATIONTESTS_CRMURL }}"
          -e IntegrationTests_CrmClientId="${{ env.INTEGRATIONTESTS_CRMCLIENTID }}"
          -e IntegrationTests_CrmClientSecret="${{ env.INTEGRATIONTESTS_CRMCLIENTSECRET }}"
          -e IntegrationTests_BuildEnvLockBlobUri="${{ env.INTEGRATIONTESTS_BUILDENVLOCKBLOBURI }}"
          -e IntegrationTests_BuildEnvLockBlobSasToken="${{ env.INTEGRATIONTESTS_BUILDENVLOCKBLOBSASTOKEN }}"
          -e IntegrationTests_TrnGenerationApi__BaseAddress="${{ env.INTEGRATIONTESTS_BUILDENVTRNGENERATIONAPIBASEADDRESS }}"
          -e IntegrationTests_TrnGenerationApi__ApiKey="${{ env.INTEGRATIONTESTS_BUILDENVTRNGENERATIONAPIAPIKEY }}"
          -e ConnectionStrings__DefaultConnection="Host=localhost;Username=postgres;Password=${{ needs.generate_postgres_password.outputs.POSTGRES_PASSWORD }};Database=dqt"

    # TODO Use migration bundles when https://github.com/dotnet/efcore/issues/25555 is fixed
    - name: Generate migrations artifact
      run: |
        mkdir migrations
        migrations_file=migrations/script.sql

        dotnet tool install --global dotnet-ef
        dotnet ef migrations script --idempotent --output $migrations_file --configuration Release --project src/DqtApi/DqtApi.csproj --no-build

        # Remove the BOM
        sed -i $'1s/^\uFEFF//' $migrations_file

        # Ensure any errors return a non-zero exit code when migrations are applied
        echo "$(echo "\set ON_ERROR_STOP true"; echo ""; cat $migrations_file)" > $migrations_file
      working-directory: DqtApi

    - name: Publish migrations
      uses: actions/upload-artifact@v3
      with:
        name: migrations
        path: DqtApi/migrations

    - name: Publish
      run: dotnet publish --configuration Release --no-build src/DqtApi/DqtApi.csproj
      working-directory: DqtApi

    - name: Docker image tag
      id: image
      run: |
        echo "tag=$CONTAINER_REGISTRY/$(echo $GITHUB_REPOSITORY | tr '[:upper:]' '[:lower:]'):$GITHUB_SHA"  >> $GITHUB_ENV

    - name: Login to GitHub Container Registry
      uses: docker/login-action@v1
      with:
        registry: ${{ env.CONTAINER_REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Docker build & push
      uses: docker/build-push-action@v2
      with:
        context: DqtApi/src/DqtApi
        push: true
        tags: ${{ env.tag }}
        build-args: |
          GIT_SHA=${{ github.sha }}

  validate_terraform:
    name: Validate Terraform
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.0.10

    - name: Check formatting
      run: terraform fmt -check -diff
      working-directory: terraform

    - name: Validate
      run: |
        terraform init -backend=false
        terraform validate -no-color
      working-directory: terraform

    - name: Lint
      uses: reviewdog/action-tflint@master
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        tflint_rulesets: azurerm
        working_directory: terraform
      continue-on-error: true  # temporary- we're getting sporadic 503 errors here in action setup

  deploy_dev:
    name: Deploy to dev environment
    needs: [build, validate_terraform]
    runs-on: ubuntu-latest
    if: (github.event_name == 'pull_request' && github.event.pull_request.draft == false) || github.event_name == 'workflow_dispatch'
    environment:
      name: dev
      url: ${{ steps.deploy.outputs.environment_url }}
    concurrency: deploy_dev

    outputs:
      environment_url: ${{ steps.deploy.outputs.environment_url }}

    steps:
    - uses: actions/checkout@v3

    - uses: ./.github/workflows/actions/deploy-environment
      id: deploy
      with:
        environment_name: dev
        docker_image: ${{ needs.build.outputs.docker_image }}
        azure_credentials: ${{ secrets.AZURE_CREDENTIALS }}
        terraform_vars: dev.tfvars.json
        terraform_backend_vars: dev.backend.tfvars

  sync_api_specs:
    name: Sync API specs
    needs: deploy_dev
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'

    steps:
    - uses: actions/checkout@v3

    - name: Generate specs
      shell: pwsh
      run: ./Sync-ApiSpecs.ps1 ${{ needs.deploy_dev.outputs.environment_url }}

    - name: Verify specs
      run: |
        git add docs/api-specs
        git diff --cached --quiet docs/api-specs || (
          echo "::error ::API specs are stale; run Sync-ApiSpecs.ps1"
          exit 1
        )

#  zap_scan:
#    name: OWASP ZAP API scan
#    needs: deploy_dev
#    runs-on: ubuntu-latest
#    concurrency: deploy_dev
#    strategy:
#      matrix:
#        version: [v1, v2]
#
#    steps:
#    - uses: actions/checkout@v3
#
#    - name: Create config file
#      run: |
#        echo "replacer.full_list(0).description=auth1" >> options.prop
#        echo "replacer.full_list(0).enabled=true" >> options.prop
#        echo "replacer.full_list(0).matchtype=REQ_HEADER" >> options.prop
#        echo "replacer.full_list(0).matchstr=Authorization" >> options.prop
#        echo "replacer.full_list(0).regex=false" >> options.prop
#        echo "replacer.full_list(0).replacement=Bearer ${{ needs.deploy_dev.outputs.test_user_api_key }}" >> options.prop
#
#    - uses: zaproxy/action-api-scan@v0.1.1
#      with:
#        target: ${{ needs.deploy_dev.outputs.environment_url }}swagger/${{ matrix.version }}/swagger.json
#        format: openapi
#        allow_issue_writing: false
#        fail_action: true
#        rules_file_name: '.zap/rules.tsv'
#        cmd_options: '-z "-configFile /zap/wrk/options.prop"'

  deploy_test:
    name: Deploy to test environment
    needs: [build, validate_terraform]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    environment:
      name: test
      url: ${{ steps.deploy.outputs.environment_url }}
    concurrency: deploy_test

    outputs:
      environment_url: ${{ steps.deploy.outputs.environment_url }}

    steps:
    - uses: actions/checkout@v3

    - uses: ./.github/workflows/actions/deploy-environment
      id: deploy
      with:
        environment_name: test
        docker_image: ${{ needs.build.outputs.docker_image }}
        azure_credentials: ${{ secrets.AZURE_CREDENTIALS }}
        terraform_vars: test.tfvars.json
        terraform_backend_vars: test.backend.tfvars

  deploy_preprod:
    name: Deploy to pre-production environment
    needs: [build, deploy_test]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    environment:
      name: pre-production
      url: ${{ steps.deploy.outputs.environment_url }}
    concurrency: deploy_preprod

    outputs:
      environment_url: ${{ steps.deploy.outputs.environment_url }}

    steps:
    - uses: actions/checkout@v3

    - uses: ./.github/workflows/actions/deploy-environment
      id: deploy
      with:
        environment_name: pre-production
        docker_image: ${{ needs.build.outputs.docker_image }}
        azure_credentials: ${{ secrets.AZURE_CREDENTIALS }}
        terraform_vars: pre-production.tfvars.json
        terraform_backend_vars: pre-production.backend.tfvars

  deploy_prod:
    name: Deploy to production environment
    needs: [build, deploy_preprod]
    runs-on: ubuntu-latest
    if: (github.ref == 'refs/heads/main' && github.event_name != 'workflow_dispatch') || (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_to_production == 'true')
    environment:
      name: production
      url: ${{ steps.deploy.outputs.environment_url }}
    concurrency: deploy_prod

    outputs:
      environment_url: ${{ steps.deploy.outputs.environment_url }}

    steps:
    - uses: actions/checkout@v3

    - uses: ./.github/workflows/actions/deploy-environment
      id: deploy
      with:
        environment_name: production
        docker_image: ${{ needs.build.outputs.docker_image }}
        azure_credentials: ${{ secrets.AZURE_CREDENTIALS }}
        terraform_vars: production.tfvars.json
        terraform_backend_vars: production.backend.tfvars
        skip_functional_tests: true
